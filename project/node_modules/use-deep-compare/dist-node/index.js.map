{"version":3,"file":"index.js","sources":["../dist-src/useDeepCompareMemoize.js","../dist-src/useDeepCompareCallback.js","../dist-src/useDeepCompareEffect.js","../dist-src/useDeepCompareImperativeHandle.js","../dist-src/useDeepCompareLayoutEffect.js","../dist-src/useDeepCompareMemo.js"],"sourcesContent":["import React from 'react';\nimport { dequal } from 'dequal';\nexport function useDeepCompareMemoize(dependencies) {\n  const dependenciesRef = React.useRef(dependencies);\n  const signalRef = React.useRef(0);\n\n  if (!dequal(dependencies, dependenciesRef.current)) {\n    dependenciesRef.current = dependencies;\n    signalRef.current += 1;\n  }\n\n  return React.useMemo(() => dependenciesRef.current, [signalRef.current]);\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareCallback` will return a memoized version of the callback that\n * only changes if one of the `dependencies` has changed.\n *\n * Warning: `useDeepCompareCallback` should not be used with dependencies that\n * are all primitive values. Use `React.useCallback` instead.\n *\n * @see {@link https://react.dev/reference/react/useCallback}\n */\n\nexport function useDeepCompareCallback(callback, dependencies) {\n  return React.useCallback(callback, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * Warning: `useDeepCompareEffect` should not be used with dependencies that\n * are all primitive values. Use `React.useEffect` instead.\n *\n * @see {@link https://react.dev/reference/react/useEffect}\n */\n\nexport function useDeepCompareEffect(effect, dependencies) {\n  React.useEffect(effect, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareImperativeHandle` customizes the instance value that is exposed to parent components when using `ref`.\n * As always, imperative code using refs should be avoided in most cases.\n *\n * `useDeepCompareImperativeHandle` should be used with `React.forwardRef`.\n *\n * It's similar to `useImperativeHandle`, but uses deep comparison on the dependencies.\n *\n * Warning: `useDeepCompareImperativeHandle` should not be used with dependencies that\n * are all primitive values. Use `React.useImperativeHandle` instead.\n *\n * @see {@link https://react.dev/reference/react/useImperativeHandle}\n */\n\nexport function useDeepCompareImperativeHandle(ref, init, dependencies) {\n  React.useImperativeHandle(ref, init, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * The signature is identical to `useDeepCompareEffect`, but it fires synchronously after all DOM mutations.\n * Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n * `useDeepCompareLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n *\n * Prefer the standard `useDeepCompareEffect` when possible to avoid blocking visual updates.\n *\n * If youâ€™re migrating code from a class component, `useDeepCompareLayoutEffect` fires in the same phase as\n * `componentDidMount` and `componentDidUpdate`.\n *\n * Warning: `useDeepCompareLayoutEffect` should not be used with dependencies that\n * are all primitive values. Use `React.useLayoutEffect` instead.\n *\n * @see {@link https://react.dev/reference/react/useLayoutEffect}\n */\n\nexport function useDeepCompareLayoutEffect(effect, dependencies) {\n  React.useLayoutEffect(effect, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareMemo` will only recompute the memoized value when one of the\n * `dependencies` has changed.\n *\n * Warning: `useDeepCompareMemo` should not be used with dependencies that\n * are all primitive values. Use `React.useMemo` instead.\n *\n * @see {@link https://react.dev/reference/react/useMemo}\n */\n\nexport function useDeepCompareMemo(factory, dependencies) {\n  return React.useMemo(factory, useDeepCompareMemoize(dependencies));\n}"],"names":["useDeepCompareMemoize","dependencies","dependenciesRef","React","useRef","signalRef","dequal","current","useMemo","useDeepCompareCallback","callback","useCallback","useDeepCompareEffect","effect","useEffect","useDeepCompareImperativeHandle","ref","init","useImperativeHandle","useDeepCompareLayoutEffect","useLayoutEffect","useDeepCompareMemo","factory"],"mappings":";;;;;;;;;AAEO,SAASA,qBAAT,CAA+BC,YAA/B,EAA6C;QAC5CC,eAAe,GAAGC,KAAK,CAACC,MAAN,CAAaH,YAAb,CAAxB;QACMI,SAAS,GAAGF,KAAK,CAACC,MAAN,CAAa,CAAb,CAAlB;;MAEI,CAACE,aAAM,CAACL,YAAD,EAAeC,eAAe,CAACK,OAA/B,CAAX,EAAoD;IAClDL,eAAe,CAACK,OAAhB,GAA0BN,YAA1B;IACAI,SAAS,CAACE,OAAV,IAAqB,CAArB;;;SAGKJ,KAAK,CAACK,OAAN,CAAc,MAAMN,eAAe,CAACK,OAApC,EAA6C,CAACF,SAAS,CAACE,OAAX,CAA7C,CAAP;;;ACTF;;;;;;;;;;AAUA,AAAO,SAASE,sBAAT,CAAgCC,QAAhC,EAA0CT,YAA1C,EAAwD;SACtDE,KAAK,CAACQ,WAAN,CAAkBD,QAAlB,EAA4BV,qBAAqB,CAACC,YAAD,CAAjD,CAAP;;;ACXF;;;;;;;;;AASA,AAAO,SAASW,oBAAT,CAA8BC,MAA9B,EAAsCZ,YAAtC,EAAoD;EACzDE,KAAK,CAACW,SAAN,CAAgBD,MAAhB,EAAwBb,qBAAqB,CAACC,YAAD,CAA7C;;;ACVF;;;;;;;;;;;;;;AAcA,AAAO,SAASc,8BAAT,CAAwCC,GAAxC,EAA6CC,IAA7C,EAAmDhB,YAAnD,EAAiE;EACtEE,KAAK,CAACe,mBAAN,CAA0BF,GAA1B,EAA+BC,IAA/B,EAAqCjB,qBAAqB,CAACC,YAAD,CAA1D;;;ACfF;;;;;;;;;;;;;;;;AAgBA,AAAO,SAASkB,0BAAT,CAAoCN,MAApC,EAA4CZ,YAA5C,EAA0D;EAC/DE,KAAK,CAACiB,eAAN,CAAsBP,MAAtB,EAA8Bb,qBAAqB,CAACC,YAAD,CAAnD;;;ACjBF;;;;;;;;;;AAUA,AAAO,SAASoB,kBAAT,CAA4BC,OAA5B,EAAqCrB,YAArC,EAAmD;SACjDE,KAAK,CAACK,OAAN,CAAcc,OAAd,EAAuBtB,qBAAqB,CAACC,YAAD,CAA5C,CAAP;;;;;;;;;"}