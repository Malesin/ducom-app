{"version":3,"file":"index.js","sources":["../dist-src/useDeepCompareMemoize.js","../dist-src/useDeepCompareCallback.js","../dist-src/useDeepCompareEffect.js","../dist-src/useDeepCompareImperativeHandle.js","../dist-src/useDeepCompareLayoutEffect.js","../dist-src/useDeepCompareMemo.js"],"sourcesContent":["import React from 'react';\nimport { dequal } from 'dequal';\nexport function useDeepCompareMemoize(dependencies) {\n  const dependenciesRef = React.useRef(dependencies);\n  const signalRef = React.useRef(0);\n\n  if (!dequal(dependencies, dependenciesRef.current)) {\n    dependenciesRef.current = dependencies;\n    signalRef.current += 1;\n  }\n\n  return React.useMemo(() => dependenciesRef.current, [signalRef.current]);\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareCallback` will return a memoized version of the callback that\n * only changes if one of the `dependencies` has changed.\n *\n * Warning: `useDeepCompareCallback` should not be used with dependencies that\n * are all primitive values. Use `React.useCallback` instead.\n *\n * @see {@link https://react.dev/reference/react/useCallback}\n */\n\nexport function useDeepCompareCallback(callback, dependencies) {\n  return React.useCallback(callback, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * Warning: `useDeepCompareEffect` should not be used with dependencies that\n * are all primitive values. Use `React.useEffect` instead.\n *\n * @see {@link https://react.dev/reference/react/useEffect}\n */\n\nexport function useDeepCompareEffect(effect, dependencies) {\n  React.useEffect(effect, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareImperativeHandle` customizes the instance value that is exposed to parent components when using `ref`.\n * As always, imperative code using refs should be avoided in most cases.\n *\n * `useDeepCompareImperativeHandle` should be used with `React.forwardRef`.\n *\n * It's similar to `useImperativeHandle`, but uses deep comparison on the dependencies.\n *\n * Warning: `useDeepCompareImperativeHandle` should not be used with dependencies that\n * are all primitive values. Use `React.useImperativeHandle` instead.\n *\n * @see {@link https://react.dev/reference/react/useImperativeHandle}\n */\n\nexport function useDeepCompareImperativeHandle(ref, init, dependencies) {\n  React.useImperativeHandle(ref, init, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * The signature is identical to `useDeepCompareEffect`, but it fires synchronously after all DOM mutations.\n * Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n * `useDeepCompareLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n *\n * Prefer the standard `useDeepCompareEffect` when possible to avoid blocking visual updates.\n *\n * If youâ€™re migrating code from a class component, `useDeepCompareLayoutEffect` fires in the same phase as\n * `componentDidMount` and `componentDidUpdate`.\n *\n * Warning: `useDeepCompareLayoutEffect` should not be used with dependencies that\n * are all primitive values. Use `React.useLayoutEffect` instead.\n *\n * @see {@link https://react.dev/reference/react/useLayoutEffect}\n */\n\nexport function useDeepCompareLayoutEffect(effect, dependencies) {\n  React.useLayoutEffect(effect, useDeepCompareMemoize(dependencies));\n}","import React from 'react';\nimport { useDeepCompareMemoize } from \"./useDeepCompareMemoize.js\";\n/**\n * `useDeepCompareMemo` will only recompute the memoized value when one of the\n * `dependencies` has changed.\n *\n * Warning: `useDeepCompareMemo` should not be used with dependencies that\n * are all primitive values. Use `React.useMemo` instead.\n *\n * @see {@link https://react.dev/reference/react/useMemo}\n */\n\nexport function useDeepCompareMemo(factory, dependencies) {\n  return React.useMemo(factory, useDeepCompareMemoize(dependencies));\n}"],"names":[],"mappings":";;;AAEO,SAAS,qBAAqB,CAAC,YAAY,EAAE;EAClD,MAAM,eAAe,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;EACnD,MAAM,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;;EAElC,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,eAAe,CAAC,OAAO,CAAC,EAAE;IAClD,eAAe,CAAC,OAAO,GAAG,YAAY,CAAC;IACvC,SAAS,CAAC,OAAO,IAAI,CAAC,CAAC;GACxB;;EAED,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,eAAe,CAAC,OAAO,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;;;CAC1E,DCVD;;;;;;;;;;AAUA,AAAO,SAAS,sBAAsB,CAAC,QAAQ,EAAE,YAAY,EAAE;EAC7D,OAAO,KAAK,CAAC,WAAW,CAAC,QAAQ,EAAE,qBAAqB,CAAC,YAAY,CAAC,CAAC,CAAC;;;CACzE,DCZD;;;;;;;;;AASA,AAAO,SAAS,oBAAoB,CAAC,MAAM,EAAE,YAAY,EAAE;EACzD,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,qBAAqB,CAAC,YAAY,CAAC,CAAC,CAAC;;;CAC9D,DCXD;;;;;;;;;;;;;;AAcA,AAAO,SAAS,8BAA8B,CAAC,GAAG,EAAE,IAAI,EAAE,YAAY,EAAE;EACtE,KAAK,CAAC,mBAAmB,CAAC,GAAG,EAAE,IAAI,EAAE,qBAAqB,CAAC,YAAY,CAAC,CAAC,CAAC;;;CAC3E,DChBD;;;;;;;;;;;;;;;;AAgBA,AAAO,SAAS,0BAA0B,CAAC,MAAM,EAAE,YAAY,EAAE;EAC/D,KAAK,CAAC,eAAe,CAAC,MAAM,EAAE,qBAAqB,CAAC,YAAY,CAAC,CAAC,CAAC;;;CACpE,DClBD;;;;;;;;;;AAUA,AAAO,SAAS,kBAAkB,CAAC,OAAO,EAAE,YAAY,EAAE;EACxD,OAAO,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,qBAAqB,CAAC,YAAY,CAAC,CAAC,CAAC;;;;;"}